import{g,bi as f,x as O,F as B,Q as x,a as M,v as q,r as A,bd as D,bj as I}from"./assets/index-BDcs8OaA.js";import{g as C,a as P,p as S}from"./aF5kppaH.js";(function(){try{var e=typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},n=new Error().stack;n&&(e._sentryDebugIds=e._sentryDebugIds||{},e._sentryDebugIds[n]="128dd1ea-1eb3-4e1b-ba85-d84710aec95e",e._sentryDebugIdIdentifier="sentry-dbid-128dd1ea-1eb3-4e1b-ba85-d84710aec95e")}catch{}})();const U=(e,n)=>[g.Avalanche,g.Ethereum,g.BinanceSmartChain].includes(e.chain)?!!n.find(a=>a.toLowerCase()===e.address?.toLowerCase()):!0,T=(e,n)=>e.chain in n&&n?.[e.chain]?.balance.find(r=>r?.eq?.(e))||e,R=()=>B.get("https://thornode.thorswap.net/thorchain/inbound_addresses"),v=async e=>{const a=(await R()).find(i=>i.chain===e);return parseInt(a.gas_rate)},V=async({recipient:e,route:n,feeOptionKey:a,wallet:i})=>{const r=n.meta.quoteMode;switch(r){case f.TC_SUPPORTED_TO_AVAX:case f.TC_SUPPORTED_TO_TC_SUPPORTED:case f.ETH_TO_AVAX:case f.ETH_TO_TC_SUPPORTED:case f.TC_SUPPORTED_TO_ETH:{const{fromAsset:s,amountIn:m,memo:w}=n.calldata,c=await O.fromIdentifier(s,m);if(!c)throw new Error("Asset not recognised");const t=w.replace("{recipientAddress}",e),o=(await R()).find(p=>p.chain===c.chain);if(!o)throw new Error("pool address not found");if(o?.halted)throw new Error("Network temporarily halted, please try again later.");const{address:h}=o,_=c.chain,l=i[c.chain].walletMethods;if(!l)throw new Error(`Chain ${_} is not connected`);const d={recipient:h,memo:t,feeOptionKey:a,from:l.getAddress(),assetValue:c,feeRate:parseInt(o.gas_rate)};return l.transfer(d)}default:throw new Error(`Quote mode ${r} not supported`)}},G=e=>{const{data:n}=x(void 0,{skip:e}),a=M(({app:{feeOptionType:t}})=>t),{getWalletAddress:i,wallet:r,getWallet:s}=q(),m=A.useCallback(t=>!!s(t.chain),[s]),w=A.useCallback(t=>!!s(t),[s]),c=A.useCallback(async(t,E=e)=>{if(E)return T(t,r);const{chain:o}=t,h=s(o);if(!h)return t.mul(0);const _=n?.find(({asset:u})=>O.fromStringSync(u).chain===o);D&&o===g.Bitcoin&&v(o).then(u=>{const W=C({gasPrice:u/1e8,feeOptionType:a,multiplier:P(t)}),k=S({gasRate:W,asset:t}),b=T(t,r),y=I(b)?b.sub(k):b;return y.gt(0)?y:b.set(0)});const l=C({gasPrice:_?.gasAsset||0,feeOptionType:a,multiplier:P(t)||1}),d=T(t,r);if(d.eqValue(0))return d;const p=D?h?.balance.find(u=>u.eq(t))||t.set(0):I(t)?d.sub(S({gasRate:l,asset:t})):d;return p.gt(0)?p:t.set(0)},[e,r,s,n,a]);return{getWalletAddress:i,isWalletAssetConnected:m,isWalletConnected:w,getMaxBalance:c}};export{T as g,U as i,V as l,G as u};
