import{ao as e,ar as g,as as _,at as h,_ as y,au as b}from"./assets/index-BDcs8OaA.js";import{Psbt as k}from"./oTdZkjon.js";(function(){try{var t=typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},i=new Error().stack;i&&(t._sentryDebugIds=t._sentryDebugIds||{},t._sentryDebugIds[i]="b657778c-d1ff-486b-91a7-8fff4e95938d",t._sentryDebugIdIdentifier="sentry-dbid-b657778c-d1ff-486b-91a7-8fff4e95938d")}catch{}})();const x=t=>async({from:i,recipient:m,amount:f,asset:l,memo:u})=>{var c;const d=(c=window.okxwallet)==null?void 0:c.keplr,r=d?.getOfflineSignerOnlyAmino(h.Cosmos);if(!r)throw new Error("No cosmos okxwallet found");const{createSigningStargateClient:o}=await y(()=>import("./9Kp3GYpY.js").then(w=>w.s),__vite__mapDeps([0,1,2])),s=await o(t||b.Cosmos,r),a=[{denom:l?.symbol==="MUON"?"umuon":"uatom",amount:f.amount().toString()}],{transactionHash:n}=await s.sendTokens(i,m,a,1.6,u);return n},v=async({chain:t,ethplorerApiKey:i,covalentApiKey:m,blockchairApiKey:f,rpcUrl:l,api:u})=>{var c,d,r;switch(t){case e.Ethereum:case e.Avalanche:case e.Arbitrum:case e.Optimism:case e.Polygon:case e.BinanceSmartChain:{if(!((c=window.okxwallet)!=null&&c.send))throw new Error("No okxwallet found");const{getWeb3WalletMethods:o,getProvider:s}=await y(()=>import("./assets/index-BDcs8OaA.js").then(w=>w.fi),__vite__mapDeps([1,2])),a=await o({chain:t,ethplorerApiKey:i,covalentApiKey:m,ethereumWindowProvider:window.okxwallet}),n=(await window.okxwallet.send("eth_requestAccounts",[])).result[0];return{...a,getAddress:()=>n,getBalance:async(w,p=!0)=>a.getBalance(w||n,p,s(t))}}case e.Bitcoin:{if(!((d=window.okxwallet)!=null&&d.bitcoin))throw new Error("No bitcoin okxwallet found");const{BTCToolbox:o}=await y(()=>import("./oTdZkjon.js"),__vite__mapDeps([3,1,2])),s=window.okxwallet.bitcoin,a=(await s.connect()).address,n=o({rpcUrl:l,apiKey:f,apiClient:u}),w=async p=>{const A=await s.signPsbt(p.toHex(),{from:a,type:"list"});return k.fromHex(A)};return{...n,transfer:p=>n.transfer({...p,signTransaction:w}),getAddress:()=>a}}case e.Cosmos:{if(!((r=window.okxwallet)!=null&&r.keplr))throw new Error("No cosmos okxwallet found");const o=window.okxwallet.keplr;await o.enable(h.Cosmos);const[{address:s}]=await o.getOfflineSignerOnlyAmino(h.Cosmos).getAccounts(),{GaiaToolbox:a}=await y(()=>import("./9Kp3GYpY.js").then(n=>n.s),__vite__mapDeps([0,1,2]));return{...a({server:u}),transfer:x(l),getAddress:()=>s}}default:throw new Error(`No wallet for chain ${t}`)}};e.Arbitrum,e.Avalanche,e.BinanceSmartChain,e.Optimism,e.Polygon,e.Bitcoin,e.Ethereum,e.Cosmos;const E=({addChain:t,config:{thorswapApiKey:i,covalentApiKey:m,ethplorerApiKey:f,utxoApiKey:l,blockchairApiKey:u}})=>async c=>{g({apiKey:i});const d=c.map(async r=>{const o=await v({chain:r,covalentApiKey:m,ethplorerApiKey:f,blockchairApiKey:u||l});t({chain:r,walletMethods:o,wallet:{address:o.getAddress(),balance:[],walletType:_.OKX}})});await Promise.all(d)},P={connectMethodName:"connectOkx",connect:E};export{P as okxWallet};
function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = ["9Kp3GYpY.js","assets/index-BDcs8OaA.js","assets/index-PWKo4Vxk.css","oTdZkjon.js"]
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}
